import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  try {
    // Test the slide JSON contract generated by the orchestrator
    // This validates that the orchestrator output is compatible with SlideElementRenderer
    
    const testSlideFromOrchestrator = {
      id: "slide_2",
      title: "Key Performance Metrics",
      type: "chart",
      content: {
        headline: "Performance Dashboard",
        chartType: "bar",
        keyMessage: "Strong growth across key metrics"
      },
      style: {
        background: { type: "solid", value: "#FFFFFF" },
        typography: {
          titleFont: "Inter, sans-serif",
          titleSize: "32px",
          titleColor: "#1F2937",
          bodyFont: "Inter, sans-serif",
          bodySize: "18px",
          bodyColor: "#1F2937"
        },
        layout: { template: "chart-focus", alignment: "left", spacing: "24px" },
        colors: { primary: "#3B82F6", secondary: "#1E40AF", accent: "#F59E0B", text: "#1F2937" }
      },
      animation: { entrance: "fadeInUp", transition: "slide", duration: 500 },
      order: 2,
      charts: [{
        id: "chart_1",
        type: "bar",
        title: "Performance Dashboard",
        data: [
          { name: "2024-01-01", value: 1072 },
          { name: "2024-02-01", value: 786 },
          { name: "2024-03-01", value: 376 },
          { name: "2024-04-01", value: 343 }
        ],
        config: {
          xAxis: "name",
          yAxis: "value",
          colors: ["#3B82F6", "#EF4444", "#10B981", "#F59E0B", "#8B5CF6"],
          showLegend: true,
          showGrid: true,
          interactive: true
        },
        style: { width: 600, height: 400, position: { x: 100, y: 200 } }
      }],
      elements: [{
        id: "element_chart_1",
        type: "chart",
        position: { x: 100, y: 200 },
        size: { width: 600, height: 400 },
        rotation: 0,
        isLocked: false,
        isVisible: true,
        chartData: [
          { name: "2024-01-01", value: 1072 },
          { name: "2024-02-01", value: 786 },
          { name: "2024-03-01", value: 376 },
          { name: "2024-04-01", value: 343 }
        ],
        chartType: "bar",
        metadata: {
          title: "Performance Dashboard",
          xAxis: "name",
          yAxis: "value",
          showGrid: true,
          showLegend: true,
          insight: "Strong growth across key metrics"
        },
        style: {
          colors: ["#3B82F6", "#EF4444", "#10B981", "#F59E0B", "#8B5CF6"]
        },
        content: "Performance Dashboard"
      }]
    }
    
    // Validate the slide element contract
    const validationResults = {
      elementValidation: {},
      chartValidation: {},
      compatibilityIssues: []
    }
    
    // Check if elements match SlideElementRenderer interface
    testSlideFromOrchestrator.elements.forEach((element: any) => {
      const elementValidation: any = {
        hasRequiredFields: true,
        fieldValidation: {}
      }
      
      // Check required fields from SlideElementRenderer interface
      const requiredFields = ['id', 'type', 'position', 'size', 'rotation']
      requiredFields.forEach(field => {
        if (!(field in element)) {
          elementValidation.hasRequiredFields = false
          elementValidation.fieldValidation[field] = 'missing'
        } else {
          elementValidation.fieldValidation[field] = 'present'
        }
      })
      
      // Validate position structure
      if (element.position) {
        if (typeof element.position.x === 'number' && typeof element.position.y === 'number') {
          elementValidation.fieldValidation.position = 'valid'
        } else {
          elementValidation.fieldValidation.position = 'invalid - x,y must be numbers'
          validationResults.compatibilityIssues.push(`Element ${element.id}: position requires numeric x,y coordinates`)
        }
      }
      
      // Validate size structure
      if (element.size) {
        if (typeof element.size.width === 'number' && typeof element.size.height === 'number') {
          elementValidation.fieldValidation.size = 'valid'
        } else {
          elementValidation.fieldValidation.size = 'invalid - width,height must be numbers'
          validationResults.compatibilityIssues.push(`Element ${element.id}: size requires numeric width,height`)
        }
      }
      
      // Validate chart-specific fields
      if (element.type === 'chart') {
        if (element.chartData && Array.isArray(element.chartData)) {
          elementValidation.fieldValidation.chartData = 'valid'
        } else {
          elementValidation.fieldValidation.chartData = 'missing or invalid'
          validationResults.compatibilityIssues.push(`Chart element ${element.id}: requires chartData array`)
        }
        
        if (element.chartType && typeof element.chartType === 'string') {
          elementValidation.fieldValidation.chartType = 'valid'
        } else {
          elementValidation.fieldValidation.chartType = 'missing or invalid'
          validationResults.compatibilityIssues.push(`Chart element ${element.id}: requires chartType string`)
        }
      }
      
      validationResults.elementValidation[element.id] = elementValidation
    })
    
    // Test TremorChartRenderer compatibility
    if (testSlideFromOrchestrator.charts && testSlideFromOrchestrator.charts.length > 0) {
      testSlideFromOrchestrator.charts.forEach((chart: any) => {
        const chartValidation: any = {
          hasValidData: false,
          dataStructure: 'unknown',
          tremorCompatibility: 'unknown'
        }
        
        if (chart.data && Array.isArray(chart.data) && chart.data.length > 0) {
          chartValidation.hasValidData = true
          
          // Check data structure
          const firstDataPoint = chart.data[0]
          if (typeof firstDataPoint === 'object' && firstDataPoint !== null) {
            const keys = Object.keys(firstDataPoint)
            if (keys.length >= 2) {
              chartValidation.dataStructure = 'valid - object with multiple keys'
              chartValidation.tremorCompatibility = 'compatible'
            } else {
              chartValidation.dataStructure = 'insufficient keys'
              chartValidation.tremorCompatibility = 'may have issues'
            }
          } else {
            chartValidation.dataStructure = 'invalid - not objects'
            chartValidation.tremorCompatibility = 'incompatible'
          }
        }
        
        validationResults.chartValidation[chart.id] = chartValidation
      })
    }
    
    // Overall assessment
    const overallAssessment = {
      isCompatible: validationResults.compatibilityIssues.length === 0,
      totalElements: testSlideFromOrchestrator.elements.length,
      totalCharts: testSlideFromOrchestrator.charts.length,
      validElements: Object.values(validationResults.elementValidation).filter((v: any) => v.hasRequiredFields).length,
      issueCount: validationResults.compatibilityIssues.length,
      contractCompliance: 'full' as string
    }
    
    if (overallAssessment.issueCount > 0) {
      overallAssessment.contractCompliance = overallAssessment.issueCount <= 2 ? 'minor-issues' : 'major-issues'
    }
    
    return NextResponse.json({
      success: true,
      testResults: {
        overallAssessment,
        validationResults,
        testSlide: {
          id: testSlideFromOrchestrator.id,
          title: testSlideFromOrchestrator.title,
          elementCount: testSlideFromOrchestrator.elements.length,
          chartCount: testSlideFromOrchestrator.charts.length
        },
        recommendations: validationResults.compatibilityIssues.length > 0 ? [
          "Review and fix the identified compatibility issues",
          "Ensure all elements have required fields (id, type, position, size, rotation)",
          "Validate chart data structure for Tremor compatibility"
        ] : [
          "Slide JSON contract is fully compatible with SlideElementRenderer",
          "Chart data structure is compatible with TremorChartRenderer",
          "No issues found - ready for production use"
        ]
      }
    })
    
  } catch (error) {
    console.error('‚ùå Slide renderer test failed:', error)
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 })
  }
}