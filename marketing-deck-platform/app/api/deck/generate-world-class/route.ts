import { NextRequest, NextResponse } from 'next/server'
import { getAuthenticatedUserWithDemo } from '@/lib/auth/api-auth'
import { createServerSupabaseClient } from '@/lib/supabase/server-client'
import { InsightEnhancer } from '@/lib/ai/insight-enhancer'
import { getEnhancedPrompt } from '@/lib/ai/world-class-prompts'
import { selectBestTemplate, adaptTemplateToContext } from '@/lib/ai/deck-templates'
import { applyVisualExcellence } from '@/lib/ai/visual-excellence'
import { AIPoweredSlideBuilder } from '@/lib/ai/ai-powered-slide-builder'
import { createCustomizedDeckStructure } from './createCustomizedDeckStructure'
import { OpenAI } from 'openai'

// Generate intelligent slide content using OpenAI
async function generateIntelligentSlideContent(
  slideStructure: any, 
  relevantInsights: any[], 
  dataset: any, 
  context: any,
  slideIndex: number
): Promise<any> {
  console.log(`ðŸ§  Generating intelligent content for: ${slideStructure.title}`)
  
  try {
    const openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
      timeout: 30000
    })

    const prompt = `You are a BigBrain Analyticsâ„¢ senior consultant creating slide content for an executive presentation.

SLIDE DETAILS:
- Title: ${slideStructure.title}
- Purpose: ${slideStructure.purpose}
- Type: ${slideStructure.type}
- Key Message: ${slideStructure.key_message || 'Strategic insight presentation'}
- Position: Slide ${slideIndex + 1} in presentation

BUSINESS CONTEXT:
- Industry: ${context.industry || 'General Business'}
- Audience: ${context.audience || 'Executives'}
- Goal: ${context.goal || 'Strategic Analysis'}
- Company Size: ${context.companySize || 'Medium'}

RELEVANT INSIGHTS:
${relevantInsights.map((insight, i) => `${i + 1}. ${insight.title}: ${insight.description}
   Business Impact: ${insight.businessImplication}`).join('\n')}

DATA CONTEXT:
- Dataset: ${dataset.filename}
- Rows: ${dataset.processed_data?.length || 0}
- Key Metrics: ${Object.keys(dataset.processed_data?.[0] || {}).join(', ')}

CONTENT REQUIREMENTS:
1. Create SPECIFIC, ACTIONABLE content - not generic templates
2. Use REAL numbers and metrics from the context
3. Include strategic recommendations with expected ROI
4. Format for executive consumption (concise, impactful)
5. Connect insights to business outcomes
6. Include implementation steps where relevant

Generate content as bullet points with:
- Executive summary (1-2 sentences)
- Key findings (3-4 strategic bullet points)
- Business impact (quantified where possible)
- Recommended actions (specific next steps)

Return content as an array of strings suitable for presentation slides.`

    const response = await Promise.race([
      openai.chat.completions.create({
        model: "gpt-4o",
        messages: [
          {
            role: "system",
            content: "You are an expert BigBrain Analyticsâ„¢ consultant creating executive presentation content. Always provide specific, actionable insights with real business value."
          },
          {
            role: "user",
            content: prompt
          }
        ],
        temperature: 0.1,
        max_tokens: 1000
      }),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('OpenAI timeout')), 25000)
      )
    ])

    const content = response.choices[0]?.message?.content
    if (!content) {
      throw new Error('No content generated by OpenAI')
    }

    // Convert response to structured content
    const lines = content.split('\n').filter(line => line.trim())
    const structuredContent = lines.map(line => line.replace(/^[â€¢\-\*]\s*/, '').trim()).filter(line => line)

    console.log(`âœ… Generated ${structuredContent.length} content items for slide: ${slideStructure.title}`)
    console.log(`ðŸ“ Content preview: ${structuredContent.slice(0, 2).join(' | ')}`)
    return structuredContent

  } catch (error) {
    console.error(`âŒ OpenAI content generation failed for ${slideStructure.title}:`, error)
    
    // Fallback content based on slide type and insights
    return generateFallbackContent(slideStructure, relevantInsights, context)
  }
}

// Fallback content generation
function generateFallbackContent(slideStructure: any, relevantInsights: any[], context: any): string[] {
  const content = []
  
  switch (slideStructure.type) {
    case 'title':
      content.push(
        `Executive Summary: ${context.goal || 'Strategic Analysis'}`,
        `Key findings from comprehensive data analysis`,
        `Strategic recommendations for ${context.industry || 'business'} optimization`,
        `Actionable insights for immediate implementation`
      )
      break
      
    case 'insight':
      if (relevantInsights.length > 0) {
        content.push(`Strategic Insight: ${relevantInsights[0].title}`)
        content.push(relevantInsights[0].description)
        content.push(`Business Impact: ${relevantInsights[0].businessImplication}`)
        content.push('Recommended Actions: Implement strategic initiatives to capitalize on this opportunity')
      }
      break
      
    case 'recommendations':
      content.push(
        'Strategic Recommendations:',
        'â€¢ Optimize operational efficiency through data-driven improvements',
        'â€¢ Implement targeted growth initiatives in high-potential areas',
        'â€¢ Establish monitoring systems for key performance indicators',
        'â€¢ Develop contingency plans for identified risk factors'
      )
      break
      
    default:
      content.push(
        `${slideStructure.title} Analysis`,
        'Strategic analysis reveals key opportunities for improvement',
        'Data-driven insights support informed decision making',
        'Recommended actions align with business objectives'
      )
  }
  
  return content
}

interface GenerationContext {
  audience: string
  goal: string
  timeLimit: number
  industry: string
  decision: string
}

interface DataProfile {
  hasTimeSeries: boolean
  hasComparisons: boolean
  hasCorrelations: boolean
  complexity: 'low' | 'medium' | 'high'
  storyType: 'growth' | 'decline' | 'comparison' | 'discovery'
}

export async function POST(request: NextRequest) {
  // Add overall timeout protection for the entire request
  return await Promise.race([
    generateWorldClassDeck(request),
    new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Request timed out after 2 minutes')), 120000)
    )
  ]).catch((error) => {
    console.error('âŒ World-class generation timed out or failed:', error)
    return NextResponse.json({ 
      error: 'Generation timed out. Please try again.', 
      fallback: true 
    }, { status: 408 })
  })
}

async function generateWorldClassDeck(request: NextRequest) {
  try {
    const { datasetId, context } = await request.json() as {
      datasetId: string
      context: any // Changed to accept user feedback data
    }
    
    console.log('ðŸš€ Starting world-class deck generation...', { 
      datasetId, 
      contextKeys: Object.keys(context),
      approvedInsights: context.approvedInsights?.length || 0,
      userCustomizedSlides: context.userCustomizedSlides || false,
      deckStructure: context.deckStructure ? 'present' : 'missing'
    })
    
    // Get authenticated user with demo support
    const { user, isDemo } = await getAuthenticatedUserWithDemo()
    if (!user) {
      return NextResponse.json({ error: 'Authentication required' }, { status: 401 })
    }
    
    console.log('ðŸ‘¤ User:', user.id, '(Demo:', isDemo, ')')
    
    // Initialize Supabase client
    const supabase = await createServerSupabaseClient()
    
    const userId = user.id
    
    // 1. Fetch real data (with demo support)
    let dataset: any
    
    if (isDemo || datasetId.startsWith('demo-')) {
      // Demo dataset - use sample data
      dataset = {
        id: datasetId,
        filename: 'demo-sales-data.csv',
        user_id: userId,
        processed_data: [
          { Date: '2024-01-01', Region: 'North America', Revenue: 45000, Units_Sold: 120, Product_Category: 'Electronics' },
          { Date: '2024-01-02', Region: 'Europe', Revenue: 38000, Units_Sold: 95, Product_Category: 'Electronics' },
          { Date: '2024-01-03', Region: 'Asia Pacific', Revenue: 52000, Units_Sold: 140, Product_Category: 'Software' },
          { Date: '2024-01-04', Region: 'North America', Revenue: 47000, Units_Sold: 125, Product_Category: 'Software' },
          { Date: '2024-01-05', Region: 'Europe', Revenue: 41000, Units_Sold: 110, Product_Category: 'Hardware' },
          { Date: '2024-01-06', Region: 'Asia Pacific', Revenue: 55000, Units_Sold: 150, Product_Category: 'Electronics' },
          { Date: '2024-01-07', Region: 'Latin America', Revenue: 28000, Units_Sold: 75, Product_Category: 'Software' },
          { Date: '2024-01-08', Region: 'Middle East', Revenue: 35000, Units_Sold: 90, Product_Category: 'Hardware' },
          { Date: '2024-01-09', Region: 'North America', Revenue: 49000, Units_Sold: 130, Product_Category: 'Electronics' },
          { Date: '2024-01-10', Region: 'Europe', Revenue: 43000, Units_Sold: 115, Product_Category: 'Software' }
        ]
      }
      console.log('ðŸ“Š Using demo dataset with', dataset.processed_data.length, 'rows')
    } else {
      // Real dataset from database
      const { data: fetchedDataset, error: datasetError } = await supabase
        .from('datasets')
        .select('*')
        .eq('id', datasetId)
        .eq('user_id', userId)
        .single()
      
      if (datasetError || !fetchedDataset) {
        console.error('Dataset fetch error:', datasetError)
        return NextResponse.json({ error: 'Dataset not found' }, { status: 404 })
      }
      
      dataset = fetchedDataset
    }
    
    console.log('ðŸ“Š Dataset loaded:', { 
      id: dataset.id, 
      filename: dataset.filename,
      rowCount: dataset.processed_data?.length || 0
    })
    
    // 2. Analyze data characteristics
    const dataProfile = analyzeDataProfile(dataset.processed_data)
    console.log('ðŸ” Data profile:', dataProfile)
    
    // 3. Select and adapt best template
    const baseTemplate = selectBestTemplate(dataProfile, context)
    const template = adaptTemplateToContext(baseTemplate, context, dataProfile)
    console.log('ðŸ“‹ Template selected:', template.name)
    
    // 4. Use approved insights from user or generate new ones
    let worldClassInsights
    if (context.approvedInsights && context.approvedInsights.length > 0) {
      console.log('âœ… Using user-approved insights:', context.approvedInsights.length)
      worldClassInsights = context.approvedInsights
    } else {
      console.log('ðŸ”„ Generating new insights (no user approval data)')
      const enhancer = new InsightEnhancer()
      const rawInsights = await generateInitialInsights(dataset, context)
      console.log('ðŸ’¡ Raw insights generated:', rawInsights.length)
      
      worldClassInsights = await enhancer.enhanceInsights(rawInsights, dataset, context)
      console.log('âœ¨ Enhanced insights:', worldClassInsights.length)
    }
    
    // 5. Create deck structure using AI-generated user structure
    let deck
    if (context.deckStructure && context.userCustomizedSlides) {
      console.log('ðŸŽ¯ Using AI-generated user-customized deck structure')
      
      // Convert the AI-generated structure into slides with proper content
      const intelligentSlides = await Promise.all(
        context.deckStructure.slides
          .filter((slideStructure: any) => slideStructure.enabled)
          .map(async (slideStructure: any, index: number) => {
            console.log(`ðŸ§  Creating AI slide: ${slideStructure.title}`)
            
            // Find relevant insights for this slide - prioritize high-quality insights
            const relevantInsights = worldClassInsights.filter((insight: any) => 
              slideStructure.purpose?.toLowerCase().includes(insight.title?.toLowerCase()) ||
              slideStructure.title?.toLowerCase().includes(insight.title?.toLowerCase()) ||
              slideStructure.type === 'insight'
            ).slice(0, 3) // Limit to top 3 most relevant insights
            
            // If no relevant insights found for this slide, use the top insights anyway
            if (relevantInsights.length === 0 && slideStructure.type === 'insight') {
              relevantInsights.push(...worldClassInsights.slice(0, 2))
            }
            
            // Generate intelligent content for this slide using context and insights
            const slideContent = await generateIntelligentSlideContent(
              slideStructure, 
              relevantInsights, 
              dataset, 
              context,
              index
            )
            
            return {
              id: slideStructure.id,
              title: slideStructure.title,
              content: slideContent,
              type: slideStructure.type,
              purpose: slideStructure.purpose,
              key_message: slideStructure.key_message,
              insights: relevantInsights,
              order: slideStructure.order,
              aiGenerated: true,
              insightSummary: relevantInsights.map(i => ({
                title: i.title,
                description: i.description,
                businessImplication: i.businessImplication,
                confidence: i.confidence
              }))
            }
          })
      )
      
      deck = {
        title: context.deckStructure.title,
        slides: intelligentSlides,
        description: context.deckStructure.description,
        purpose: context.deckStructure.purpose,
        aiStructured: true
      }
      
    } else {
      console.log('ðŸ”„ Creating standard deck structure (fallback)')
      deck = await createDeckStructure(template, worldClassInsights, dataset, context)
    }
    console.log('ðŸ—ï¸ Deck structure created:', { slides: deck.slides.length, aiStructured: deck.aiStructured })
    
    // 6. Apply visual excellence with advanced styling
    const polishedSlides = applyVisualExcellence(deck.slides, context.audience || 'executive', 'advanced')
    console.log('ðŸŽ¨ Visual excellence applied with advanced styling')
    
    // 6.5. Use AI-Powered Slide Builder with advanced editor features
    console.log('ðŸŽ¨ Initializing AI-Powered Slide Builder with advanced editor integration...')
    const aiSlideBuilder = new AIPoweredSlideBuilder()
    
    const aiEnhancedSlides = []
    for (const [index, slide] of polishedSlides.entries()) {
      console.log(`ðŸŽ¯ Building slide ${index + 1} with AI editor features...`)
      
      try {
        const slideResult = await aiSlideBuilder.buildSlideWithAdvancedFeatures({
          title: slide.title || `Slide ${index + 1}`,
          content: slide.content || [],
          businessContext: context.goal || 'strategic analysis',
          audienceLevel: context.audience || 'executive',
          designGoal: 'professional presentation with Fortune 500 quality',
          dataVisualizations: slide.charts || [],
          enhancedInsights: slide.insightSummary || [], // Pass the enhanced insights
          slideType: slide.type,
          keyMessage: slide.key_message
        })
        
        console.log(`âœ… Slide ${index + 1} AI elements:`, {
          elementsCount: slideResult.elements?.length || 0,
          hasContent: slideResult.elements?.some(e => e.content),
          elementTypes: slideResult.elements?.map(e => e.type) || []
        })
        
        // Log first element for debugging
        if (slideResult.elements && slideResult.elements.length > 0) {
          console.log(`ðŸ“ First element content preview:`, 
            slideResult.elements[0].content?.substring(0, 100) || 'No content')
        }
      
        aiEnhancedSlides.push({
          ...slide,
          elements: slideResult.elements,
          design: slideResult.design,
          layers: slideResult.layers,
          groups: slideResult.groups,
          animations: slideResult.animations,
          aiPowered: true,
          editorFeatures: {
            smartPositioning: true,
            professionalLayers: true,
            advancedAnimations: true,
            intelligentGrouping: true,
            responsiveDesign: true
          },
          metadata: {
            ...slide.metadata,
            aiReasoning: slideResult.reasoning,
            generatedWithEditorFeatures: true,
            designPrinciples: ['hierarchy', 'balance', 'contrast', 'alignment'],
            interactionLevel: 'advanced'
          }
        })
      } catch (error) {
        console.error(`âŒ Error building slide ${index + 1}:`, error)
        // Use the original slide with fallback elements
        aiEnhancedSlides.push({
          ...slide,
          elements: slide.elements || [],
          aiPowered: false,
          editorFeatures: {
            smartPositioning: false,
            professionalLayers: false,
            advancedAnimations: false,
            intelligentGrouping: false,
            responsiveDesign: false
          }
        })
      }
    }
    
    console.log('âœ¨ AI-Powered slides with advanced editor features generated')
    const polishedDeck = aiEnhancedSlides
    
    // 7. Generate executive coaching
    const coachingNotes = await generatePresentationCoaching(polishedDeck, context)
    console.log('ðŸŽ¤ Coaching notes generated')
    
    // 8. Save to database (with demo support)
    let savedDeck: any
    
    if (isDemo) {
      // Demo mode - generate a mock deck ID and don't save to database
      savedDeck = {
        id: `demo-deck-${Date.now()}`,
        title: deck.title,
        template_name: template.name,
        slide_count: polishedDeck.length,
        user_id: userId,
        dataset_id: datasetId
      }
      console.log('ðŸ’¾ Demo deck created:', savedDeck.id)
    } else {
      // Real mode - save to database with enhanced persistence
      try {
        const { serverPresentationService, EnhancedPresentationService } = await import('@/lib/services/enhanced-presentation-service')
        
        // Create presentation data
        const presentationData = EnhancedPresentationService.createPresentationFromDeck({
          deckId: `deck-${Date.now()}`,
          title: deck.title,
          slides: aiEnhancedSlides,
          userId: userId,
          datasetId: datasetId,
          templateId: template.name,
          qualityScore: (deck as any).qualityScore || 85
        })
        
        // Save using enhanced service
        const saveResult = await serverPresentationService.savePresentation(presentationData)
        
        if (saveResult.success) {
          savedDeck = { id: saveResult.id }
          console.log('âœ… Enhanced deck saved:', savedDeck.id)
        } else {
          throw new Error(saveResult.error)
        }
      } catch (enhancedError) {
        console.warn('âš ï¸ Enhanced save failed, using fallback:', enhancedError)
        
        // Fallback to original method
        const { data: realSavedDeck, error: saveError } = await supabase
          .from('presentations')
          .insert({
            user_id: userId,
            dataset_id: datasetId,
            title: deck.title,
            template_name: template.name,
            context: context,
            quality_score: (deck as any).qualityScore || 85,
            coaching_notes: coachingNotes,
            slide_count: aiEnhancedSlides.length,
            estimated_duration: template.duration,
            slides: aiEnhancedSlides
          })
          .select()
          .single()
        
        if (saveError) {
          console.error('Deck save error:', saveError)
          return NextResponse.json({ error: 'Failed to save deck' }, { status: 500 })
        }
        
        savedDeck = realSavedDeck
        console.log('ðŸ’¾ Fallback deck saved:', savedDeck.id)
      }
      
      // 9. Create slides with world-class content
      for (const [index, slide] of polishedDeck.entries()) {
        await createWorldClassSlide(supabase, savedDeck.id, slide, index)
      }
    }
    
    console.log('âœ… World-class deck generation complete!')
    console.log(`ðŸŽ¯ Final deck details:`)
    console.log(`   - Deck ID: ${savedDeck.id}`)
    console.log(`   - Total slides generated: ${polishedDeck.length}`)
    console.log(`   - AI-enhanced slides: ${aiEnhancedSlides.filter(s => s.aiPowered).length}`)
    console.log(`   - Template used: ${template.name}`)
    console.log(`   - Quality score: ${(deck as any).qualityScore || 85}`)
    console.log(`   - Insights processed: ${worldClassInsights.length}`)
    
    return NextResponse.json({
      success: true,
      deckId: savedDeck.id,
      slides: polishedDeck,
      quality: 'world-class',
      qualityScore: (deck as any).qualityScore || 85,
      estimatedImpact: (deck as any).estimatedImpact || 'High',
      coachingPreview: coachingNotes.keyTips,
      slidesGenerated: polishedDeck.length,
      userFeedbackProcessed: context.userCustomizedSlides || false,
      templateUsed: template.name,
      insightsEnhanced: worldClassInsights.length,
      debug: {
        aiEnhancedSlides: aiEnhancedSlides.length,
        totalSlides: polishedDeck.length,
        savedToDatabase: true,
        hasElements: polishedDeck.some(s => s.elements && s.elements.length > 0)
      }
    })
    
  } catch (error) {
    console.error('âŒ World-class deck generation failed:', error)
    return NextResponse.json({ 
      error: error instanceof Error ? error.message : 'Deck generation failed',
      details: error instanceof Error ? error.stack : undefined
    }, { status: 500 })
  }
}

async function generateInitialInsights(dataset: any, context: GenerationContext) {
  try {
    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY })
    
    const prompt = getEnhancedPrompt(context.audience, dataset.processed_data, context)
    
    const response = await openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      messages: [
        { role: "system", content: prompt },
        { 
          role: "user", 
          content: `Analyze this data and generate strategic insights for ${context.audience}:
          
Dataset: ${dataset.filename}
Data sample: ${JSON.stringify(dataset.processed_data.slice(0, 20))}
Total rows: ${dataset.processed_data.length}

Generate 8-10 high-impact insights that would be valuable for ${context.goal}.` 
        }
      ],
      temperature: 0.7,
      response_format: { type: "json_object" }
    })
    
    const result = JSON.parse(response.choices[0].message.content || '{"insights": []}')
    return result.insights || []
    
  } catch (error) {
    console.error('Error generating initial insights:', error)
    // Fallback insights based on data analysis
    return generateFallbackInsights(dataset, context)
  }
}

function generateFallbackInsights(dataset: any, context: GenerationContext) {
  const data = dataset.processed_data || []
  const insights = []
  
  if (data.length === 0) {
    return [{ text: "No data available for analysis", type: "data-quality" }]
  }
  
  // Basic data insights
  insights.push({
    text: `Dataset contains ${data.length} records for analysis`,
    type: "overview"
  })
  
  // Column analysis
  const columns = Object.keys(data[0] || {})
  const numericColumns = columns.filter(col => 
    data.slice(0, 10).every((row: any) => !isNaN(parseFloat(row[col])))
  )
  
  if (numericColumns.length > 0) {
    insights.push({
      text: `Key metrics identified: ${numericColumns.join(', ')}`,
      type: "metrics"
    })
  }
  
  // Time series detection
  const dateColumns = columns.filter(col =>
    data.slice(0, 5).some((row: any) => {
      const val = row[col]
      return val && new Date(val).toString() !== 'Invalid Date'
    })
  )
  
  if (dateColumns.length > 0) {
    insights.push({
      text: `Time-based analysis possible with ${dateColumns[0]}`,
      type: "temporal"
    })
  }
  
  return insights
}

async function createDeckStructure(template: any, insights: any[], dataset: any, context: GenerationContext) {
  const slides = []
  
  // Generate title
  const title = generateDeckTitle(dataset, context)
  
  // Create slides based on template
  for (const slideTemplate of template.slides) {
    const slide = await createSlideFromTemplate(slideTemplate, insights, dataset, context)
    slides.push(slide)
  }
  
  // Calculate quality score
  const qualityScore = calculateDeckQuality(slides, insights, template)
  
  // Estimate business impact
  const estimatedImpact = estimateBusinessImpact(insights, context)
  
  return {
    title,
    slides,
    qualityScore,
    estimatedImpact,
    template: template.name
  }
}

function generateDeckTitle(dataset: any, context: GenerationContext): string {
  const industry = context.industry || 'Business'
  const goal = context.goal || 'Analysis'
  
  const titles = [
    `${industry} ${goal.charAt(0).toUpperCase() + goal.slice(1)} - Strategic Analysis`,
    `Data-Driven Insights for ${industry} Growth`,
    `${dataset.filename.replace('.csv', '')} - Executive Summary`,
    `Strategic Analysis: ${industry} Performance Review`
  ]
  
  return titles[Math.floor(Math.random() * titles.length)]
}

async function createSlideFromTemplate(slideTemplate: any, insights: any[], dataset: any, context: GenerationContext) {
  const slide: any = {
    type: slideTemplate.type,
    title: slideTemplate.title || `${slideTemplate.type.charAt(0).toUpperCase() + slideTemplate.type.slice(1)}`,
    layout: slideTemplate.layout,
    duration: slideTemplate.duration,
    content: [] as string[],
    elements: [] as any[],
    charts: [] as any[]
  }
  
  // Generate content based on slide type with SOPHISTICATED content
  switch (slideTemplate.type) {
    case 'executiveSummary':
      slide.title = `Executive Summary - ${context.industry} Strategic Analysis`
      slide.content = generateExecutiveSummary(insights, context)
      slide.charts = insights.length > 2 ? generateExecutiveDashboard(dataset, insights) : []
      break
      
    case 'kpiDashboard':
      const kpiGoal = context.goal || 'Strategic Analysis'
      slide.title = `Key Performance Indicators - ${kpiGoal.charAt(0).toUpperCase() + kpiGoal.slice(1)}`
      slide.content = generateKPIDashboard(dataset, context)
      slide.charts = generateDashboardCharts(dataset)
      break
      
    case 'deepDive':
      const topInsight = insights[0]
      if (topInsight) {
        slide.title = topInsight.headline || topInsight.title || 'Critical Strategic Finding'
        slide.content = [
          `â€¢ ${topInsight.impact || topInsight.businessImplication || 'High-impact business insight'}`,
          ...((topInsight.evidence || topInsight.dataPoints || []).slice(0, 3).map((evidence: string) => `â€¢ ${evidence}`)),
          `â€¢ Confidence Level: ${topInsight.confidence || 85}%`,
          `â€¢ Business Impact: ${topInsight.businessImpact || 'Significant'}`
        ]
        slide.charts = topInsight.visualizations ? [topInsight.visualizations[0]] : []
      }
      break
      
    case 'recommendations':
      slide.title = `Strategic Recommendations - ${context.decision || 'Action Plan'}`
      slide.content = generateRecommendations(insights, context)
      break
      
    case 'dataInsights':
      slide.title = `Data-Driven Insights - ${dataset.filename.replace('.csv', '')}`
      slide.content = generateDataInsightContent(insights, dataset)
      slide.charts = generateInsightCharts(insights, dataset)
      break
      
    default:
      slide.title = `${slideTemplate.type.charAt(0).toUpperCase() + slideTemplate.type.slice(1)} Analysis`
      slide.content = [`Professional ${slideTemplate.type} content for ${context.industry} industry`]
  }
  
  return slide
}

// Enhanced content generation functions
function generateDataInsightContent(insights: any[], dataset: any): string[] {
  const content = [
    `Analysis of ${dataset.processed_data?.length || 0} records reveals key patterns:`,
  ]
  
  insights.slice(0, 4).forEach((insight, index) => {
    content.push(`${index + 1}. ${insight.title || insight.headline}: ${insight.description || insight.finding}`)
  })
  
  return content
}

function generateInsightCharts(insights: any[], dataset: any): any[] {
  const charts = insights.slice(0, 2).map((insight, index) => {
    const chartData = generateChartDataFromInsight(insight, dataset)
    const chartType = index === 0 ? 'bar' : 'line'
    
    return {
      type: chartType,
      title: insight.title || `Strategic Insight ${index + 1}`,
      subtitle: insight.businessImplication ? insight.businessImplication.substring(0, 60) + '...' : undefined,
      data: chartData,
      
      // World-class Tremor chart configuration
      tremorConfig: {
        type: chartType,
        title: insight.title || `Strategic Insight ${index + 1}`,
        data: chartData,
        xAxisKey: chartData.length > 0 ? Object.keys(chartData[0])[0] : 'name',
        yAxisKey: chartData.length > 0 ? Object.keys(chartData[0])[1] : 'value',
        colors: ['#1e40af', '#2563eb', '#3b82f6', '#60a5fa', '#93c5fd'],
        colorPalette: 'blue',
        showLegend: false,
        showGrid: true,
        showTooltip: true,
        animateOnLoad: true,
        animationDuration: 800,
        responsive: true,
        height: 300,
        businessMetric: extractBusinessMetric(insight),
        insightLevel: 'strategic',
        audienceLevel: 'executive',
        consultingStyle: {
          emphasizeInsight: insight.businessImplication || `Key finding from ${insight.title}`,
          calloutValue: getCalloutValue(chartData),
          calloutLabel: 'Peak Performance',
          benchmark: index === 1 ? {
            value: calculateBenchmark(chartData),
            label: 'Industry Standard',
            color: '#ef4444'
          } : undefined,
          annotations: generateAnnotations(chartData, insight)
        }
      },
      
      complexity: 'executive',
      mckinsey_style: true
    }
  })
  
  return charts
}

// Helper functions for enhanced chart generation
function extractBusinessMetric(insight: any): string {
  const title = insight.title?.toLowerCase() || ''
  if (title.includes('revenue')) return 'Revenue Performance'
  if (title.includes('customer')) return 'Customer Metrics'
  if (title.includes('growth')) return 'Growth Analysis'
  if (title.includes('market')) return 'Market Position'
  if (title.includes('efficiency')) return 'Operational Efficiency'
  return 'Business Performance'
}

function getCalloutValue(data: any[]): number | string {
  if (!data || data.length === 0) return 'N/A'
  
  const values = data.map(d => Object.values(d)[1]).filter(v => typeof v === 'number') as number[]
  if (values.length === 0) return 'N/A'
  
  const maxValue = Math.max(...values)
  
  // Format large numbers appropriately
  if (maxValue > 1000000) return `${(maxValue / 1000000).toFixed(1)}M`
  if (maxValue > 1000) return `${(maxValue / 1000).toFixed(1)}K`
  return maxValue.toFixed(0)
}

function calculateBenchmark(data: any[]): number {
  if (!data || data.length === 0) return 0
  
  const values = data.map(d => Object.values(d)[1]).filter(v => typeof v === 'number') as number[]
  if (values.length === 0) return 0
  
  // Calculate 75th percentile as benchmark
  const sorted = values.sort((a, b) => a - b)
  const index = Math.floor(sorted.length * 0.75)
  return sorted[index] || 0
}

function generateAnnotations(data: any[], insight: any): Array<{x: number | string, y: number, text: string, color?: string}> {
  if (!data || data.length === 0) return []
  
  const annotations = []
  
  // Find peak performance point
  const values = data.map(d => Object.values(d)[1]).filter(v => typeof v === 'number') as number[]
  if (values.length === 0) return []
  
  const maxValue = Math.max(...values)
  const maxIndex = values.indexOf(maxValue)
  
  if (maxIndex !== -1 && data[maxIndex]) {
    annotations.push({
      x: Object.values(data[maxIndex])[0] as string,
      y: 20, // 20% from top
      text: 'Peak',
      color: '#059669'
    })
  }
  
  // Add insight-specific annotation
  if (insight.confidence && insight.confidence > 90) {
    annotations.push({
      x: '50%', // Center
      y: 10, // 10% from top
      text: `${insight.confidence}% Confidence`,
      color: '#7c3aed'
    })
  }
  
  return annotations
}

function generateChartDataFromInsight(insight: any, dataset: any): any[] {
  // Generate realistic chart data based on insight
  const data = dataset.processed_data || []
  if (data.length === 0) return []
  
  const numericColumns = Object.keys(data[0] || {}).filter(col =>
    data.slice(0, 5).every((row: any) => !isNaN(parseFloat(row[col])))
  )
  
  if (numericColumns.length === 0) return []
  
  const column = numericColumns[0]
  return data.slice(0, 8).map((row: any, index: number) => ({
    name: row.Date || row.Category || `Point ${index + 1}`,
    value: parseFloat(row[column]) || Math.random() * 100
  }))
}

function generateExecutiveDashboard(dataset: any, insights: any[]): any[] {
  const data = dataset.processed_data || []
  if (data.length === 0) return []
  
  return [{
    type: 'gauge',
    title: 'Overall Performance Score',
    data: [{
      name: 'Score',
      value: Math.round((insights.reduce((sum: number, insight: any) => sum + (insight.confidence || 75), 0) / insights.length))
    }],
    complexity: 'medium'
  }]
}

function generateExecutiveSummary(insights: any[], context: GenerationContext): string[] {
  const goal = context.goal || 'Strategic Analysis'
  const summary = [
    `Executive Summary - ${goal.charAt(0).toUpperCase() + goal.slice(1)}`
  ]
  
  // Add top 3-4 insights
  insights.slice(0, 4).forEach((insight, index) => {
    summary.push(`${index + 1}. ${insight.headline || insight.text}`)
  })
  
  return summary
}

function generateKPIDashboard(dataset: any, context: GenerationContext): string[] {
  const data = dataset.processed_data || []
  if (data.length === 0) return ['No KPI data available']
  
  const columns = Object.keys(data[0] || {})
  const numericColumns = columns.filter(col => 
    data.slice(0, 10).every((row: any) => !isNaN(parseFloat(row[col])))
  )
  
  const kpis = numericColumns.slice(0, 4).map(col => {
    const values = data.map((row: any) => parseFloat(row[col])).filter((val: number) => !isNaN(val))
    const avg = values.reduce((sum: number, val: number) => sum + val, 0) / values.length
    return `${col}: ${avg.toFixed(2)} (average)`
  })
  
  return kpis.length > 0 ? kpis : ['KPI analysis pending']
}

function generateDashboardCharts(dataset: any): any[] {
  const data = dataset.processed_data || []
  if (data.length === 0) return []
  
  const columns = Object.keys(data[0] || {})
  const numericColumns = columns.filter(col => 
    data.slice(0, 10).every((row: any) => !isNaN(parseFloat(row[col])))
  )
  
  return numericColumns.slice(0, 3).map(col => ({
    type: 'gauge',
    title: col,
    data: data.map((row: any) => parseFloat(row[col])).filter((val: number) => !isNaN(val))
  }))
}

function generateRecommendations(insights: any[], context: GenerationContext): string[] {
  const recommendations = ['Recommended Actions:']
  
  insights.slice(0, 3).forEach((insight, index) => {
    if (insight.action) {
      recommendations.push(`${index + 1}. ${insight.action}`)
    } else {
      recommendations.push(`${index + 1}. Investigate ${insight.headline || insight.text}`)
    }
  })
  
  return recommendations
}

function generateSlideElements(slide: any, slideTemplate: any, design?: any): any[] {
  const elements = []
  
  // Use sophisticated visual excellence system
  const layoutRules = design?.layout || {
    margins: { top: 80, right: 80, bottom: 80, left: 80 },
    grid: { columns: 12, gutter: 24 },
    maxWidth: 1200
  }
  
  const typography = design?.typography || {
    title: { size: 48, weight: 700, lineHeight: 1.2 },
    subtitle: { size: 28, weight: 500, lineHeight: 1.4 },
    body: { size: 18, weight: 400, lineHeight: 1.6 }
  }
  
  const colors = design?.colors || {
    background: '#ffffff',
    text: '#1a365d',
    headings: '#153e75',
    accent: '#2a69ac'
  }
  
  const modernStyling = design?.modernStyling || {
    shadows: '0 4px 12px rgba(0,0,0,0.15)',
    borderRadius: 8,
    gradients: { enabled: true, intensity: 0.8 }
  }
  
  // SOPHISTICATED TITLE with executive styling
  if (slide.title) {
    elements.push({
      type: 'title',
      content: slide.title,
      position: { 
        x: layoutRules.margins.left, 
        y: layoutRules.margins.top 
      },
      size: { 
        width: layoutRules.maxWidth - layoutRules.margins.left - layoutRules.margins.right, 
        height: typography.title.size * 1.5 
      },
      style: {
        fontSize: typography.title.size,
        fontWeight: typography.title.weight,
        lineHeight: typography.title.lineHeight,
        color: colors.headings,
        fontFamily: '"Inter", system-ui, sans-serif',
        textAlign: 'left',
        background: modernStyling.gradients.enabled ? 
          `linear-gradient(135deg, ${colors.headings} 0%, ${colors.accent} 100%)` : colors.headings,
        WebkitBackgroundClip: 'text',
        WebkitTextFillColor: 'transparent',
        textShadow: '0 2px 4px rgba(0,0,0,0.1)',
        marginBottom: 20
      },
      metadata: {
        designLevel: 'executive',
        visualImpact: 'high',
        businessRelevance: 'primary'
      }
    })
  }
  
  // SMART CONTENT LAYOUT using grid system
  let currentY = layoutRules.margins.top + (typography.title.size * 2)
  const contentWidth = (layoutRules.maxWidth - layoutRules.margins.left - layoutRules.margins.right)
  
  slide.content?.forEach((item: string, index: number) => {
    const isKeyPoint = item.includes('â€¢') || item.match(/^\d+\./);
    const elementHeight = isKeyPoint ? 60 : 45;
    
    elements.push({
      type: 'text',
      content: item,
      position: { 
        x: layoutRules.margins.left + (isKeyPoint ? 40 : 0), 
        y: currentY 
      },
      size: { 
        width: contentWidth - (isKeyPoint ? 40 : 0), 
        height: elementHeight 
      },
      style: {
        fontSize: isKeyPoint ? typography.body.size + 2 : typography.body.size,
        fontWeight: isKeyPoint ? 600 : typography.body.weight,
        lineHeight: typography.body.lineHeight,
        color: isKeyPoint ? colors.headings : colors.text,
        fontFamily: '"Inter", system-ui, sans-serif',
        padding: '12px 20px',
        borderRadius: modernStyling.borderRadius,
        background: isKeyPoint ? 
          `linear-gradient(135deg, rgba(42, 105, 172, 0.08) 0%, rgba(21, 62, 117, 0.12) 100%)` : 
          'transparent',
        boxShadow: isKeyPoint ? modernStyling.shadows : 'none',
        border: isKeyPoint ? `1px solid ${colors.accent}20` : 'none',
        marginBottom: 16,
        transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)'
      },
      animations: {
        entrance: 'fadeInUp',
        delay: index * 200,
        duration: 600
      },
      metadata: {
        contentType: isKeyPoint ? 'keyPoint' : 'supporting',
        visualPriority: isKeyPoint ? 'high' : 'medium'
      }
    })
    
    currentY += elementHeight + 16
  })
  
  // WORLD-CLASS CHART INTEGRATION with advanced styling
  slide.charts?.forEach((chart: any, index: number) => {
    const chartWidth = contentWidth * 0.6 // Use 60% of content width
    const chartHeight = 300 + (chart.complexity === 'high' ? 100 : 0)
    const chartX = layoutRules.margins.left + (contentWidth - chartWidth) / 2 // Center horizontally
    
    elements.push({
      type: 'chart',
      chartConfig: {
        ...chart,
        // Enhanced chart styling
        colors: design?.chartColors || generateExecutiveChartColors(chart.type),
        styling: {
          fontSize: 14,
          fontFamily: '"Inter", system-ui, sans-serif',
          gridLines: { color: '#e2e8f0', strokeWidth: 1 },
          borderRadius: modernStyling.borderRadius,
          boxShadow: modernStyling.shadows,
          background: 'linear-gradient(135deg, #ffffff 0%, #f8fafc 100%)',
          border: `1px solid ${colors.accent}20`,
          padding: 20
        },
        animations: {
          entrance: getChartAnimationType(chart.type),
          duration: 1200,
          delay: 800,
          easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
        },
        interactivity: {
          hover: { scale: 1.02, shadow: '0 8px 32px rgba(0,0,0,0.25)' },
          tooltip: { 
            background: colors.headings, 
            color: '#ffffff',
            borderRadius: modernStyling.borderRadius,
            fontSize: 12,
            fontWeight: 500
          }
        }
      },
      position: { x: chartX, y: currentY + 40 },
      size: { width: chartWidth, height: chartHeight },
      style: {
        borderRadius: modernStyling.borderRadius,
        boxShadow: modernStyling.shadows,
        background: 'linear-gradient(135deg, #ffffff 0%, #f8fafc 100%)',
        border: `1px solid ${colors.accent}20`,
        overflow: 'hidden'
      },
      metadata: {
        visualType: 'dataVisualization',
        businessImportance: 'high',
        interactionLevel: 'advanced'
      }
    })
    
    currentY += chartHeight + 60
  })
  
  return elements
}

// Helper function for executive-grade chart colors
function generateExecutiveChartColors(chartType: string): string[] {
  const executivePalettes = {
    bar: ['#1e40af', '#2563eb', '#3b82f6', '#60a5fa', '#93c5fd'],
    line: ['#1e40af', '#dc2626', '#059669', '#d97706', '#7c3aed'],
    pie: ['#1e40af', '#2563eb', '#3b82f6', '#60a5fa', '#93c5fd', '#dbeafe'],
    scatter: ['#1e40af', '#dc2626', '#059669'],
    area: ['#1e40af', '#2563eb', '#3b82f6'],
    default: ['#1e40af', '#2563eb', '#3b82f6', '#60a5fa', '#93c5fd']
  }
  
  return executivePalettes[chartType as keyof typeof executivePalettes] || executivePalettes.default
}

// Helper function for chart animation types
function getChartAnimationType(chartType: string): string {
  const animations = {
    line: 'drawPath',
    bar: 'growHeight', 
    pie: 'rotateSegments',
    scatter: 'bubbleIn',
    area: 'fillArea',
    gauge: 'sweepNeedle',
    default: 'fadeIn'
  }
  
  return (animations as any)[chartType] || animations.default
}

async function createWorldClassSlide(supabase: any, deckId: string, slideData: any, index: number) {
  try {
    // Use sophisticated design from visual excellence system
    const designColors = slideData.design?.colors || {
      background: '#ffffff',
      text: '#1a365d',
      headings: '#153e75',
      accent: '#2a69ac'
    }
    
    const modernStyling = slideData.design?.modernStyling || {
      shadows: '0 4px 12px rgba(0,0,0,0.15)',
      borderRadius: 8,
      gradients: { enabled: true, intensity: 0.8 }
    }
    
    // Create slide with sophisticated design
    const { data: slide, error: slideError } = await supabase
      .from('slides')
      .insert({
        presentation_id: deckId,
        order_index: index,
        layout: slideData.layout,
        title: slideData.title,
        background_color: designColors.background,
        transition: slideData.design?.animations?.slideEntry?.type || 'fadeInUp',
        // Store the complete design configuration
        design_config: {
          colors: designColors,
          modernStyling: modernStyling,
          typography: slideData.design?.typography,
          animations: slideData.design?.animations,
          interactivity: slideData.design?.interactivity
        }
      })
      .select()
      .single()
    
    if (slideError) {
      console.error('Error creating slide:', slideError)
      return
    }
    
    // Add elements with world-class design
    for (const element of slideData.elements || []) {
      const { error: elementError } = await supabase
        .from('elements')
        .insert({
          slide_id: slide.id,
          type: element.type,
          content: element.content,
          position_x: element.position.x,
          position_y: element.position.y,
          width: element.size.width,
          height: element.size.height,
          style: {
            ...element.style,
            // Add sophisticated styling metadata
            designLevel: element.metadata?.designLevel || 'professional',
            visualImpact: element.metadata?.visualImpact || 'medium',
            businessRelevance: element.metadata?.businessRelevance || 'standard'
          },
          chart_config: element.chartConfig,
          z_index: element.zIndex || (index * 10),
          // Store element-specific design data
          design_metadata: element.metadata,
          animations: element.animations
        })
      
      if (elementError) {
        console.error('Error creating element:', elementError)
      }
    }
    
    console.log(`âœ… Created world-class slide ${index + 1} with ${slideData.elements?.length || 0} sophisticated elements`)
    
  } catch (error) {
    console.error('Error in createWorldClassSlide:', error)
  }
}

async function generatePresentationCoaching(deck: any, context: GenerationContext) {
  try {
    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY })
    
    const coachingPrompt = `
    Generate executive presentation coaching for this deck:
    - Audience: ${context.audience}
    - Goal: ${context.goal}
    - Time: ${context.timeLimit} minutes
    - Industry: ${context.industry}
    
    Deck has ${deck.length} slides covering: ${deck.map((s: any) => s.type).join(', ')}
    
    Provide specific coaching advice as JSON:
    {
      "keyTips": ["tip1", "tip2", "tip3"],
      "openingHook": "powerful opening statement",
      "transitions": ["slide 1 to 2", "slide 2 to 3"],
      "toughQuestions": ["q1", "q2", "q3"],
      "powerPhrases": ["phrase1", "phrase2"],
      "avoidPhrases": ["phrase1", "phrase2"],
      "bodyLanguage": ["tip1", "tip2"],
      "closingStatement": "call to action"
    }
    `
    
    const response = await openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      messages: [{ role: "user", content: coachingPrompt }],
      response_format: { type: "json_object" },
      temperature: 0.7
    })
    
    return JSON.parse(response.choices[0].message.content || '{}')
    
  } catch (error) {
    console.error('Error generating coaching:', error)
    return {
      keyTips: [
        "Start with your biggest finding",
        "Use the 'So what?' test for each slide",
        "End with specific next steps"
      ],
      openingHook: "Begin with the most important insight",
      closingStatement: "Clearly state what you need from the audience"
    }
  }
}

function analyzeDataProfile(data: any[]): DataProfile {
  if (!data || data.length === 0) {
    return {
      hasTimeSeries: false,
      hasComparisons: false,
      hasCorrelations: false,
      complexity: 'low',
      storyType: 'discovery'
    }
  }
  
  const columns = Object.keys(data[0] || {})
  
  // Detect time series
  const hasTimeSeries = detectTimeSeries(data, columns)
  
  // Detect comparisons (categorical data)
  const hasComparisons = detectCategorical(data, columns)
  
  // Detect correlations (multiple numeric columns)
  const hasCorrelations = detectCorrelations(data, columns)
  
  // Assess complexity
  const complexity = assessComplexity(data, columns)
  
  // Determine story type
  const storyType = determineStoryType(data, columns, hasTimeSeries)
  
  return {
    hasTimeSeries,
    hasComparisons,
    hasCorrelations,
    complexity,
    storyType
  }
}

function detectTimeSeries(data: any[], columns: string[]): boolean {
  return columns.some(col =>
    data.slice(0, 5).some((row: any) => {
      const val = row[col]
      return val && new Date(val).toString() !== 'Invalid Date'
    })
  )
}

function detectCategorical(data: any[], columns: string[]): boolean {
  return columns.some(col => {
    const values = data.slice(0, 20).map((row: any) => row[col])
    const uniqueValues = new Set(values)
    return uniqueValues.size < values.length * 0.8 && uniqueValues.size > 1
  })
}

function detectCorrelations(data: any[], columns: string[]): boolean {
  const numericColumns = columns.filter(col =>
    data.slice(0, 10).every((row: any) => !isNaN(parseFloat(row[col])))
  )
  
  return numericColumns.length >= 2
}

function assessComplexity(data: any[], columns: string[]): 'low' | 'medium' | 'high' {
  const columnCount = columns.length
  const rowCount = data.length
  
  if (columnCount <= 3 && rowCount <= 100) return 'low'
  if (columnCount <= 10 && rowCount <= 1000) return 'medium'
  return 'high'
}

function determineStoryType(data: any[], columns: string[], hasTimeSeries: boolean): 'growth' | 'decline' | 'comparison' | 'discovery' {
  if (hasTimeSeries) {
    // Check for growth/decline pattern
    const dateCol = columns.find(col =>
      data.slice(0, 5).some((row: any) => {
        const val = row[col]
        return val && new Date(val).toString() !== 'Invalid Date'
      })
    )
    
    if (dateCol) {
      const numericCols = columns.filter(col => col !== dateCol &&
        data.slice(0, 10).every((row: any) => !isNaN(parseFloat(row[col])))
      )
      
      if (numericCols.length > 0) {
        const values = data
          .sort((a, b) => new Date(a[dateCol]).getTime() - new Date(b[dateCol]).getTime())
          .map((row: any) => parseFloat(row[numericCols[0]]))
          .filter(val => !isNaN(val))
        
        if (values.length >= 2) {
          const trend = values[values.length - 1] - values[0]
          return trend > 0 ? 'growth' : 'decline'
        }
      }
    }
  }
  
  // Check for comparison data
  const hasCategorical = detectCategorical(data, columns)
  if (hasCategorical) return 'comparison'
  
  return 'discovery'
}

function calculateDeckQuality(slides: any[], insights: any[], template: any): number {
  let score = 0.7 // Base score for using world-class system
  
  // Bonus for enhanced insights
  if (insights.some(i => i.headline && i.impact)) score += 0.1
  
  // Bonus for appropriate template selection
  if (template.name.includes('Board') || template.name.includes('Investor')) score += 0.1
  
  // Bonus for slide count optimization
  if (slides.length >= 5 && slides.length <= 15) score += 0.05
  
  // Bonus for visual design
  if (slides.every(s => s.elements && s.elements.length > 0)) score += 0.05
  
  return Math.min(score, 1.0) // Cap at 1.0
}

function estimateBusinessImpact(insights: any[], context: GenerationContext): string {
  const hasQuantifiedInsights = insights.some(i => 
    i.impact && (i.impact.includes('$') || i.impact.includes('%'))
  )
  
  if (hasQuantifiedInsights) {
    return "High - Quantified business impact identified"
  }
  
  if ((context.goal || '').includes('funding') || (context.goal || '').includes('investment')) {
    return "High - Strategic decision support"
  }
  
  return "Medium - Actionable insights provided"
}